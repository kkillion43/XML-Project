
# MSDS 7330 - MiniProject2
# XML & Python
<br>
#### By: Kyle Killion
<hr>

##  Baseball file and process it to XML
### Take the baseball_salaries_2003.txt and clean it up as output CSV format
<hr>


```python
import pandas as pd

#Read in the baseball text file
df = pd.read_csv(r'C:\Users\hb13316\Documents\Data Science\DataBase Systems\MiniProject2\baseball_salaries_2003.txt',
                sep=':', header=2, index_col=False,
                 names=['Team','Player','Salary','Position'])

#Manually deleted Index in CSV File after it was created
#df.to_csv(r'C:\Users\hb13316\Documents\Data Science\DataBase Systems\MiniProject2\baseball_salaries_2003.csv')



```

### Now conduct Python KungFu to build the XML file based off the converted CSV file
<hr>


```python
from lxml import etree
import csv
import os
import datetime
import numpy as np
from io import StringIO

schema_text = StringIO(
r"""\
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="baseball">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element type="xs:string" name="Team"/>
        <xs:element type="xs:string" name="Player"/>
        <xs:element type="xs:int" name="Salary"/>
        <xs:element type="xs:string" name="Position"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
""")



#Initializing files and setwd()
os.chdir(r'C:\Users\hb13316\Documents\Data Science\DataBase Systems\MiniProject2')
file_name = 'baseball_salaries_2003.xml'
schema_file = 'baseball_salaries_2003_1.txt'

#Make Root of XML
root = etree.Element('baseball')
root.set('version', '1.0')

#Comment in XML file
root.append(etree.Comment('Generated by baseball_salaries_2003.csv'))
root.append(etree.Comment('%s' % str(datetime.datetime.today())))

#Read the CSV file
rdr = csv.reader(open("baseball_salaries_2003.csv"))

#This creates a list of the tags
header = next(rdr)

#Process file to XML reading rows and writing tags 
for this in header:
    try:
        for row in rdr:
            for h, v in zip(header, row):
                etree.SubElement(root, h).text = v
                
    except Exception as e:
        print(str(e))
        pass

#Write the file to XML file_name
f = open(file_name, "wb")
f.write(etree.tostring(root))
f.close()

#XML Schema Validatation
#doc = etree.parse(schema_text)
#schema = etree.XMLSchema(doc)

#doc2 = etree.parse('baseball_salaries_2003.xml')
#schema.validate(doc2)

```

### Read Xpath Queries into Pandas DataFrame to groupby
<hr>


```python
#Get my XML File created
myFile = etree.ElementTree(file='baseball_salaries_2003.xml')
    
#Xpath queries from the xml file
monies = myFile.xpath('/baseball/Salary/text()')
pos = myFile.xpath('/baseball/Position/text()')
#print(monies)
#Read in the DataFrame
df = pd.DataFrame({'Salary':pd.to_numeric(monies), 'Position':pos})

#Group and Sort Salaries
group = df.groupby('Position')
group.aggregate({'Salary': np.mean}).sort_values(by='Salary', ascending=False)



```




<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Salary</th>
    </tr>
    <tr>
      <th>Position</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Outfielder</th>
      <td>4050024</td>
    </tr>
    <tr>
      <th>First Baseman</th>
      <td>3591402</td>
    </tr>
    <tr>
      <th>Shortstop</th>
      <td>2953382</td>
    </tr>
    <tr>
      <th>Third Baseman</th>
      <td>2461333</td>
    </tr>
    <tr>
      <th>Pitcher</th>
      <td>2135130</td>
    </tr>
    <tr>
      <th>Second Baseman</th>
      <td>1307750</td>
    </tr>
    <tr>
      <th>Catcher</th>
      <td>1172669</td>
    </tr>
  </tbody>
</table>
</div>



* __Seems Outfielders and First Baseman on Average get paid the most__

# XML vs MySQL Databases
<hr>
___Under what conditions does XML provide a better database approach? Under what
conditions does MySQL provide a better database approach?___
<br>

#### XML Database approach:
* Readable
* Transmisable
* Control over configs
* Flaw : It is an elementTree much like file structures. This isn't very translatable into 2-D arrays. Also, these files are needing to be opened, parsed, modify/do your thing, and then write stdout -- Inefficient
* Can still be a good fit depending on its hierarchical nature, size, and customization needed.

#### MySQL Database approach:
* Readable
* Most Popular - flexible with other languages
* Query Power and control was better/easier
* Relational which provides easy Joins and Merges 
